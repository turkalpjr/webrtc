{"ast":null,"code":"import store from '../../store/store';\nimport { setLocalStream, setCallState, callStates, setCallingDialogVisible, setCallerUsername, setCallRejected } from '../../store/actions/callActions';\nimport * as wss from '../wssConnection/wssConnection';\nconst preOfferAnswers = {\n  CALL_ACCEPTED: 'CALL_ACCEPTED',\n  CALL_REJECTED: 'CALL_REJECTED',\n  CALL_NOT_AVAIABLE: 'CALL_NOT_AVAIABLE'\n};\nconst defaultConstrains = {\n  video: true,\n  audio: true\n};\nexport const getLocalStream = () => {\n  navigator.mediaDevices.getUserMedia(defaultConstrains).then(stream => {\n    store.dispatch(setLocalStream(stream));\n    store.dispatch(setCallState(callStates.CALL_AVAILABLE));\n  }).catch(err => {\n    console.log('error occured when trying to get an access to get local stream');\n    console.log(err);\n  });\n};\nlet connectedUserSocketId;\nexport const callToOtherUser = calleeDetails => {\n  debugger;\n  connectedUserSocketId = calleeDetails.socketId;\n  store.dispatch(setCallState(callStates.CALL_IN_PROGRESS));\n  store.dispatch(setCallingDialogVisible(true));\n  wss.sendPreOffer({\n    callee: calleeDetails,\n    caller: {\n      username: store.getState().dashboard.username\n    }\n  });\n};\nexport const handlePreOffer = data => {\n  if (checkIfCallIsPossible()) {\n    connectedUserSocketId = data.callerSocketId;\n    store.dispatch(setCallerUsername(data.callerUsername));\n    store.dispatch(setCallState(callStates.CALL_REQUESTED));\n  } else {\n    wss.sendPreOfferAnswer({\n      callerSocketId: data.callerSocketId,\n      answer: preOfferAnswers.CALL_NOT_AVAIABLE\n    });\n  }\n};\nexport const acceptIncomingCallRequest = () => {\n  wss.sendPreOfferAnswer({\n    callerSocketId: connectedUserSocketId,\n    answer: preOfferAnswers.CALL_ACCEPTED\n  });\n};\nexport const rejectIncomingCallRequest = () => {\n  wss.sendPreOfferAnswer({\n    callerSocketId: connectedUserSocketId,\n    answer: preOfferAnswers.CALL_REJECTED\n  });\n  resetCallData();\n};\nexport const handlePreOfferAnswer = data => {\n  store.dispatch(setCallingDialogVisible(false));\n  if (data.answer === preOfferAnswers.CALL_ACCEPTED) {\n    //SEND WEBRTC OFFER\n  } else {\n    let rejectionReason;\n    if (data.answer === preOfferAnswers.CALL_NOT_AVAIABLE) {\n      rejectionReason = 'Callee is not able to pic kup the call right now';\n    } else {\n      rejectionReason = 'Call rejected by the callee';\n    }\n    store.dispatch(setCallRejected({\n      rejected: true,\n      reason: rejectionReason\n    }));\n  }\n};\nexport const checkIfCallIsPossible = () => {\n  if (store.getState().call.localStream == null || store.getState().call.callState !== callStates.CALL_AVAIABLE) {\n    return false;\n  } else {\n    return true;\n  }\n};\nexport const resetCallData = () => {\n  connectedUserSocketId = null;\n  store.dispatch(setCallState(callStates.CALL_AVAIABLE));\n};","map":{"version":3,"names":["store","setLocalStream","setCallState","callStates","setCallingDialogVisible","setCallerUsername","setCallRejected","wss","preOfferAnswers","CALL_ACCEPTED","CALL_REJECTED","CALL_NOT_AVAIABLE","defaultConstrains","video","audio","getLocalStream","navigator","mediaDevices","getUserMedia","then","stream","dispatch","CALL_AVAILABLE","catch","err","console","log","connectedUserSocketId","callToOtherUser","calleeDetails","socketId","CALL_IN_PROGRESS","sendPreOffer","callee","caller","username","getState","dashboard","handlePreOffer","data","checkIfCallIsPossible","callerSocketId","callerUsername","CALL_REQUESTED","sendPreOfferAnswer","answer","acceptIncomingCallRequest","rejectIncomingCallRequest","resetCallData","handlePreOfferAnswer","rejectionReason","rejected","reason","call","localStream","callState","CALL_AVAIABLE"],"sources":["D:/videotalker/video-talker-frontend/src/utils/webRTC/webRTCHandler.js"],"sourcesContent":["import store from '../../store/store';\r\nimport { setLocalStream, setCallState, callStates, setCallingDialogVisible, setCallerUsername,setCallRejected } from '../../store/actions/callActions';\r\nimport * as wss from '../wssConnection/wssConnection';\r\n\r\n\r\nconst preOfferAnswers = {\r\n  CALL_ACCEPTED: 'CALL_ACCEPTED',\r\n  CALL_REJECTED: 'CALL_REJECTED',\r\n  CALL_NOT_AVAIABLE: 'CALL_NOT_AVAIABLE'\r\n}\r\nconst defaultConstrains = {\r\n  video: true,\r\n  audio: true\r\n};\r\n\r\nexport const getLocalStream = () => {\r\n  navigator.mediaDevices.getUserMedia(defaultConstrains)\r\n    .then(stream => {\r\n      store.dispatch(setLocalStream(stream));\r\n      store.dispatch(setCallState(callStates.CALL_AVAILABLE));\r\n    })\r\n    .catch(err => {\r\n      console.log('error occured when trying to get an access to get local stream');\r\n      console.log(err);\r\n    });\r\n}\r\n  ;\r\n\r\nlet connectedUserSocketId;\r\nexport const callToOtherUser = (calleeDetails) => {\r\n  debugger;\r\n  connectedUserSocketId = calleeDetails.socketId;\r\n  store.dispatch(setCallState(callStates.CALL_IN_PROGRESS));\r\n  store.dispatch(setCallingDialogVisible(true));\r\n  wss.sendPreOffer({\r\n    callee: calleeDetails,\r\n    caller: {\r\n      username: store.getState().dashboard.username\r\n    }\r\n  })\r\n}\r\n\r\n\r\nexport const handlePreOffer = (data) => {\r\n\r\n  if (checkIfCallIsPossible()) {\r\n    connectedUserSocketId = data.callerSocketId;\r\n    store.dispatch(setCallerUsername(data.callerUsername));\r\n    store.dispatch(setCallState(callStates.CALL_REQUESTED))\r\n  } else {\r\n    wss.sendPreOfferAnswer({\r\n      callerSocketId: data.callerSocketId,\r\n      answer: preOfferAnswers.CALL_NOT_AVAIABLE\r\n    })\r\n  }\r\n};\r\n\r\nexport const acceptIncomingCallRequest = () => {\r\n  wss.sendPreOfferAnswer({\r\n    callerSocketId: connectedUserSocketId,\r\n    answer: preOfferAnswers.CALL_ACCEPTED\r\n  });\r\n};\r\n\r\nexport const rejectIncomingCallRequest = () => {\r\n\r\n  wss.sendPreOfferAnswer({\r\n    callerSocketId: connectedUserSocketId,\r\n    answer: preOfferAnswers.CALL_REJECTED\r\n  });\r\n  resetCallData();\r\n}\r\n\r\nexport const handlePreOfferAnswer = (data) => {\r\n \r\n  store.dispatch(setCallingDialogVisible(false));\r\n  if (data.answer === preOfferAnswers.CALL_ACCEPTED) {\r\n    //SEND WEBRTC OFFER\r\n  } else {\r\n     let rejectionReason;\r\n     if(data.answer===preOfferAnswers.CALL_NOT_AVAIABLE){\r\n      rejectionReason='Callee is not able to pic kup the call right now';\r\n     }else{\r\n      rejectionReason='Call rejected by the callee';\r\n     }\r\n     store.dispatch(setCallRejected({\r\n      rejected:true,\r\n      reason:rejectionReason\r\n     }))\r\n  }\r\n};\r\n\r\nexport const checkIfCallIsPossible = () => {\r\n  if (store.getState().call.localStream == null || store.getState().call.callState !== callStates.CALL_AVAIABLE) {\r\n    return false;\r\n  }\r\n  else {\r\n    return true;\r\n  }\r\n}\r\n\r\n\r\nexport const resetCallData = () => {\r\n  connectedUserSocketId = null;\r\n  store.dispatch(setCallState(callStates.CALL_AVAIABLE));\r\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}